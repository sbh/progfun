import scala.collection.mutable.ArrayBuffer
import scala.collection.mutable.Queue

object graph1 {
  class Vertex(val key: Int)
  class EdgeNode(val y: Int, val weight: Int, val next: EdgeNode) {
    override def toString = "y = "+y
  }

  class Graph(val nvertices: Int, var nedges: Int, val directed: Boolean) {
    val edges = new Array[EdgeNode](nedges)
    val degree = new Array[Int](nedges) // degree == the number of edges from each vertex
    for (i <- 0 until edges.size) {
      edges(i) = null
      degree(i) = 0
    }

    def insertEdge(x: Int, y: Int, directed: Boolean): Unit = {
      edges(x) = new EdgeNode(y, 0, edges(x))
      degree(x) = degree(x) + 1
      if (!directed) {
        insertEdge(y, x, true)
      }
    }

    override def toString = {
      val buf = new StringBuffer()
      for (i <- 0 until nvertices) {
        buf.append(i + "(" + degree(i) + "): ")
        var p = edges(i)
        while (p != null) {
          buf.append(p.y + " ")
          p = p.next
        }
        buf.deleteCharAt(buf.length() - 1).append(", ")
      }
      buf.toString
    }
  }

  def makeGraph(nodes: List[(Int, Int)], directed: Boolean): Graph = {
    val nedges = nodes.head._2
    val graph = new Graph(nodes.head._1, nedges, false)
    for (tuple <- nodes.tail) {
      graph.insertEdge(tuple._1, tuple._2, directed)
    }

    graph
  }

  val graph1 = List((8, 10), (0, 1), (0, 6), (1, 2), (1, 3), (1, 4), (2, 6), (2, 3), (3, 4), (3, 5), (3, 7))
  val g1 = makeGraph(graph1, false)
  val g2 = makeGraph(graph1, true)

  def processVertexEarly(vertex: Int) = { /*println("early processing vertex: "+vertex)*/ }
  def processVertexLate(vertex: Int) = { /*println("late processing vertex: "+vertex)*/ }
  def processEdge(x: Int, y: Int) = { /*println("processing edge: ("+x+", "+y+")")*/ }

  def bfs(graph: Graph, start: Int): (List[Int], Array[Int]) = {
    val queue = new Queue[Int]()
    var vertices = start :: Nil
    var parents = new Array[Int](graph.nvertices)
    val discovered = new Array[Boolean](graph.nvertices)
    val processed = new Array[Boolean](graph.nvertices)
    for (i <- 0 until graph.nvertices) {
      discovered(i) = false
      processed(i) = false
      parents(i) = -1
    }

    queue.enqueue(start)
    discovered(start) = true
    while (!queue.isEmpty) {
      val v = queue.dequeue
      processVertexEarly(v)
      processed(v) = true
      //println("Looking at vertex: "+v)
      var p = graph.edges(v)
      while (p != null) {
        if (!processed(p.y) || graph.directed)
          processEdge(v, p.y)
        if (!discovered(p.y)) {
          discovered(p.y) = true
          //println("Setting "+p.y+"'s parent to "+v)
          parents(p.y) = v
          vertices = p.y :: vertices
          queue.enqueue(p.y)
          //println("Moving to p.next: "+p.next)
        }
        p = p.next
      }
      processVertexLate(v)
    }
    (vertices.reverse, parents)
  }

  def findPath(end: Int, parents: Array[Int]): List[Int] = {
    def go(y: Int, path: List[Int]): List[Int] = {
      if (parents(y) >= 0) parents(y) :: go(parents(y), path)
      else path
    }

    (end :: go(end, Nil)).reverse
  }

  val (vertices1, parents1) = bfs(g1, 0)
  findPath(5, parents1)
  /*bfs(g1, 1)
  bfs(g1, 2)
  bfs(g1, 3)
  bfs(g1, 4)
  bfs(g1, 5)
  bfs(g1, 6)
  bfs(g1, 7)
  bfs(g2, 0)*/


  val (vertices2, parents2) = bfs(g2, 1)
  findPath(5, parents2)
  /*bfs(g2, 2)
  bfs(g2, 3)
  bfs(g2, 4)
  bfs(g2, 5)
  bfs(g2, 6)
  bfs(g2, 7)*/
}
